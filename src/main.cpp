/*
  COMPILATA CON 1.8.19 

definizione board : 
https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json

** Giugno 2023

invia stringhe meteo in formato APRS con modulazione LoRa 
/*
 * Logo Images
 * draw a 1bit bitmap: pixel ON=white pixel OFF=black
 * convert using:
 * https://convertio.co/it/bmp-xbm/
 * or
 * https://www.online-utility.org/image_converter.jsp (choose XBM)
 * 
 * https://mischianti.org/images-to-byte-array-online-converter-cpp-arduino/
 * https://mischianti.org/2021/07/14/ssd1306-oled-display-draw-images-splash-and-animations-2/#Sample_sketch_to_show_the_logo



--------------- LoRa-AprsDroid ---------------





*/





#include "config.h"
#include <Arduino.h>
#include <LoRa.h>
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BMP280.h>
#include <Adafruit_BME280.h>
#include <Adafruit_AHTX0.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <EEPROM.h>//https://github.com/espressif/arduino-esp32/tree/master/libraries/EEPROM
#include "BluetoothSerial.h"
#include <SPI.h>



  /*
  ---------------------------------------------------------------------------
    VARIABILI VARIE
  ---------------------------------------------------------------------------
  */

BluetoothSerial SerialBT;
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);




boolean Xmode;
boolean token;
boolean Beacon;
unsigned long tx_interval;   // default ogni 30 secondi il token buono per fare una tx
unsigned long millis_read_batt;   // default ogni 30 secondi refresh display se abilitato
unsigned long millis_led;
byte val_tx_interval = 30;

unsigned LoRa_power=10;
float battery_voltage;

byte ptr;
byte sep;

unsigned tmp;

char tmp_buffer[60];            // a supporto seriale e menu e caricamento EEPROM

char carMenu;                   // a supporto seriale e menu
char car;                       // a supporto seriale e menu

String data_string=""; 
String mem_tmp_string="";
String tmp_string=""; 

unsigned int cnt=0;                   // contatore invio stringhe meteo
bool displayOn=true;
bool ledOn=true;
bool dataOK=false;

const unsigned char logo [] PROGMEM = {
// 'LoRa_APRSdroid', 128x64px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xde, 0x18, 0x39, 0xfd, 0xff, 0xef, 0xbf, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8c, 0x08, 0x10, 0x79, 0xff, 0xcf, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c, 0x09, 0x92, 0x69, 0x09, 0xcd, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c, 0xc8, 0x11, 0xc1, 0x00, 0x48, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xfe, 0x4c, 0x00, 0x30, 0x99, 0x22, 0x42, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x0f, 0xfe, 0x0c, 0x10, 0x7c, 0x19, 0x26, 0x42, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x03, 0xfc, 0x04, 0xf3, 0x24, 0x92, 0x66, 0x12, 0x7f, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0x80, 0xfc, 0xe1, 0xf3, 0x20, 0xc2, 0x70, 0x90, 0x7f, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xe0, 0xfd, 0xed, 0xf7, 0xfb, 0xff, 0xfb, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x7c, 0x00, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc0, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xee, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xfe, 0x00, 0xfc, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xf8, 0x00, 0x3c, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xf1, 0xff, 0x3c, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xff, 0x83, 0xfc, 0x0f, 0xe0, 0x7e, 0x03, 0x89, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xfc, 0x00, 0xfc, 0x0f, 0xe0, 0x78, 0x00, 0x81, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xf8, 0x00, 0x3c, 0x0f, 0xe0, 0x70, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xf0, 0x00, 0x3c, 0x0f, 0xe0, 0x70, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0x10, 0x1c, 0x0f, 0xc0, 0x70, 0x70, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0x7c, 0x0c, 0x00, 0x00, 0x70, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfc, 0x0c, 0x00, 0x00, 0xff, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfe, 0x0c, 0x00, 0x01, 0xfc, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfe, 0x0c, 0x00, 0x07, 0xf0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfe, 0x0c, 0x02, 0x03, 0xf0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfc, 0x0c, 0x0f, 0x03, 0xe0, 0x70, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfc, 0x0c, 0x0f, 0x01, 0xe0, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x20, 0x78, 0x1c, 0x0f, 0x81, 0xe0, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x30, 0x00, 0x1c, 0x0f, 0x80, 0xe0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x30, 0x00, 0x3c, 0x0f, 0xc0, 0x60, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x38, 0x00, 0x7c, 0x0f, 0xc0, 0x70, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x3e, 0x00, 0xfc, 0x0f, 0xe0, 0x38, 0x08, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf0, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xfc, 0xff, 0xf8, 0x66, 0xe7, 0x1e, 0x39, 0x93, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xef, 0xfc, 0xff, 0xf0, 0x44, 0xce, 0x0c, 0x09, 0x13, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc3, 0xff, 0x87, 0xfc, 0x26, 0x72, 0x44, 0x8c, 0xc8, 0xc9, 0x17, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc0, 0x10, 0x0f, 0xfc, 0x06, 0x72, 0x01, 0x0c, 0xf9, 0xf8, 0x07, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x3f, 0xf9, 0x94, 0xf2, 0x01, 0xcc, 0xf9, 0x08, 0x07, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x3e, 0x01, 0xf9, 0xf9, 0x91, 0xf2, 0x23, 0xcc, 0xc9, 0x08, 0x8f, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xe0, 0xf8, 0x31, 0xe2, 0x23, 0x9c, 0x08, 0x18, 0x8f, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x01, 0xff, 0x00, 0xf8, 0x33, 0xe6, 0x67, 0x9e, 0x1c, 0x39, 0x9f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x03, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x1f, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

/*
const unsigned char cgw [] PROGMEM = {
// '128X64', 128x64px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x07, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x7e, 0x01, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc0, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xfe, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xfe, 0x01, 0xfc, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xf8, 0x10, 0x3c, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xfb, 0xff, 0x3c, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xff, 0x83, 0xfc, 0x0f, 0xe0, 0x7f, 0x07, 0x89, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xfc, 0x00, 0xfc, 0x0f, 0xe0, 0x78, 0x00, 0x81, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xf8, 0x00, 0x3c, 0x0f, 0xe0, 0x70, 0x00, 0x51, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xf0, 0x00, 0x3c, 0x0f, 0xe0, 0x70, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xf0, 0x30, 0x1c, 0x0f, 0xc0, 0x70, 0x70, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0x7c, 0x1c, 0x00, 0x00, 0x70, 0xf8, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfc, 0x0c, 0x00, 0x00, 0xff, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfe, 0x0c, 0x00, 0x01, 0xfc, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfe, 0x0c, 0x00, 0x07, 0xf8, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfe, 0x0c, 0x06, 0x03, 0xf0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfe, 0x0c, 0x0f, 0x03, 0xe0, 0x70, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x7f, 0xe0, 0xfc, 0x0c, 0x0f, 0x01, 0xe0, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x20, 0x7c, 0x1c, 0x0f, 0x81, 0xe0, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x30, 0x00, 0x1c, 0x0f, 0x80, 0xe0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x30, 0x00, 0x3c, 0x0f, 0xc0, 0xe0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x38, 0x00, 0x7c, 0x0f, 0xe0, 0x70, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0xfe, 0x0f, 0xe0, 0x78, 0x08, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0xfc, 0xff, 0xfa, 0x66, 0xef, 0x1e, 0x3b, 0xbb, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xef, 0xfc, 0xff, 0xf2, 0x44, 0xce, 0x0c, 0x09, 0x13, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc3, 0xff, 0x87, 0xfc, 0x26, 0x72, 0x44, 0x8c, 0xc8, 0xc9, 0x17, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xe0, 0x38, 0x0f, 0xfc, 0x26, 0x72, 0x01, 0x0c, 0xf9, 0xf8, 0x07, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x3f, 0xf9, 0x94, 0xf2, 0x01, 0xcc, 0xf9, 0x08, 0x8f, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x7f, 0x83, 0xf9, 0xf9, 0x91, 0xf2, 0x23, 0xcc, 0xc9, 0x18, 0x8f, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xe0, 0xf8, 0x31, 0xe6, 0x23, 0x9c, 0x08, 0x18, 0x9f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0x01, 0xf8, 0x73, 0xe6, 0x67, 0x9e, 0x3c, 0x39, 0x9f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x07, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x1f, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

*/

void read_battery();
void initial_reset();
void lora_setup();
void lora_send(String tx_data);
void fast_blink();
void verifica_parametri();
void load_param();
void status();
void menu();
void righello();
void make_display();
void LoRa_send();



  /*
  ---------------------------------------------------------------------------
    SETUP
  ---------------------------------------------------------------------------
  */

void setup()
{
  pinMode (BATT_SENS, INPUT);
  pinMode (PLED1, OUTPUT);
  digitalWrite(PLED1,LOW); 
  
  SPI.begin();                            // initialize SPI:
  SPI.setClockDivider(SPI_CLOCK_DIV2);    
  SPI.setDataMode(SPI_MODE0);
  SPI.setBitOrder(MSBFIRST);
  
  Serial.begin(SERIAL_BAUD);
  while (!Serial) {
    Serial.println(F("Failed to setup Serial."));
    while (1);
  };
  
  if (!SerialBT.begin(BT_device_name)) {
    Serial.println(F("Failed to setup Bluetooth Serial."));
    while (1);
  };
 
 Serial.print(F("\nThe device with name "));
 Serial.print(F(BT_device_name));
 Serial.print(F(" is started.\nNow you can pair it with Bluetooth!\n" ));

  #ifdef USE_PIN
    SerialBT.setPin(pin);
    Serial.println("Using PIN");
  #endif
   
  EEPROM.begin(EEPROM_SIZE);

  load_param();
  verifica_parametri();
  read_battery();
  status();
 


  /*
  ---------------------------------------------------------------------------
    OLED_DISPLAY STARTUP
  ---------------------------------------------------------------------------
  */
 
  display.begin(SSD1306_SWITCHCAPVCC, 0x3c); 
  display.clearDisplay();
  
  display.drawBitmap(0, 0, logo, 128, 64, WHITE);
  display.display();
  delay(3000);
 
  display.clearDisplay();  
  display.setTextColor(WHITE);

  display.setTextSize(1);
  display.setCursor(0,5);
  display.print("battery:");
  display.setCursor(65,5);
  display.print(battery_voltage);
  display.setCursor(0,15);
  display.print("frequency:");
  display.setCursor(65,15);
  display.print(frequency);
  display.print(" KHz");
  display.setCursor(0,25);
  display.print("power:");
  display.setCursor(65,25);
  display.print(LoRa_power);
  display.print(" dbm");
  display.setCursor(0,35);
  display.print("interval:");
  display.setCursor(65,35);
  display.print(val_tx_interval);
  display.print(" secs");
  display.setCursor(0,45);
  display.print("---------------------");
  display.setCursor(0,55);
  display.print(Project);
  display.print(" " );
  display.print(Release);
  display.display();  

  lora_setup();
  
  delay(3000);
  make_display();
  delay(3000);
  if ( !displayOn )
    {
    display.dim(true);  
    display.display();
    }
  
  token = true;
  millis_read_batt=millis()+15000;
}



  /*
  ---------------------------------------------------------------------------
    LOOP
  ---------------------------------------------------------------------------
  */
  
void loop()
  {
  /*
  ---------------------------------------------------------------------------
    LETTURA FLUSSI SULLA SERIALE

    i dati utili si intendono quelli racchiusi entro la trama che
    inizia con '[' e termina con ']'
    i valori racchiusi sono incapsulati nella String 'tmp_string'
  ---------------------------------------------------------------------------
  */
    car = Serial.read();
    if (car == 'm' )
      {
        while (Serial.read() != '\n') {};
        menu();
      }

    if (car == 's' )
      {
        while (Serial.read() != '\n') {};
        status();
      }

    /*
    if (car == 's' )
      {
        while (Serial.read() != '\n') {};
        lora_setup();
        data_string = "IW1CGW-4>APDR16,WIDE1-1:=4419.52N/00748.29Eb/A=002274 APRSdroid LoRa tech | batt:4.28 | 005";
        lora_send(data_string);
      }
    */


   /*
  ---------------------------------------------------------------------------
    GESTIONE REFRESH DISPLAY CON DATI AGGIORNATI DELLA BATTERIA
  ---------------------------------------------------------------------------
  */
 
 if (millis()-millis_read_batt > 15000 ) // ogni 15secs leggi la tensione batteria e se del caso refresh il display
  {
    read_battery();
    millis_read_batt = millis();
    make_display();
  }



 /*
  ---------------------------------------------------------------------------
    GESTIONE LED BLINK
  ---------------------------------------------------------------------------
 */
  
  if ( ledOn ) 
    {
      if ( millis() - millis_led  < 75 ) digitalWrite(PLED1, HIGH);
      if ( millis() - millis_led  > 75 ) digitalWrite(PLED1, LOW);
      if ( millis() - millis_led > 5000 ) millis_led = millis();
    }



   /*
  ---------------------------------------------------------------------------
    GESTIONE TOKEN
  ---------------------------------------------------------------------------
  */
  
 
 if ( millis() - tx_interval > val_tx_interval*1000 ) token = true;

 //if ( Beacon && millis()-tx_interval > 30000 && token == true && mem_tmp_string != "")
 if ( Beacon && millis()-tx_interval > 600000 && token == true && mem_tmp_string != "")
  {
    tx_interval = millis();
    tmp_string = mem_tmp_string;
    dataOK=true;
    LoRa_send();   
  }

   /*
  ---------------------------------------------------------------------------
    GESTIONE DATI IN ARRIVO DA BLUETOOTH
  ---------------------------------------------------------------------------
  */
  
  if (SerialBT.available())
    {
      byte LL = SerialBT.read();
      if (LL != 10 && LL != 13 ) tmp_string = tmp_string + char(LL);  // fin che non trovi un Cr o un LF accoda caratteri 
      if (LL == 10 || LL == 13 )                                      // se trovi CR o LF risolvi stringa completa e invia a sender
        {
          dataOK=false;
          if ( tmp_string.indexOf('/')-tmp_string.indexOf(':') == 10 ) dataOK = true;                              // cerca il primo carattere di separazione '/'
          
          //Serial.println(F("BT:"));
          //Serial.println(tmp_string);
          //Serial.println(tmp_string.indexOf('/')-tmp_string.indexOf(':'));
          //if ( dataOK == true ) Serial.println("dataOK = true");
          //if ( dataOK == false ) Serial.println("dataOK = false");
          //Serial.println(tmp_string.indexOf('/')-tmp_string.indexOf(':') );
          //LatLong_string = tmp_string.substring(sep-8, sep+10);       // estrai latitudine e longitudine muovendoti dalla posizione di '/'
          
          
          if ( tmp_string == "beacon") 
            { 
              Beacon = !Beacon;
              if (Beacon) SerialBT.println("beacon on");
              if (!Beacon) SerialBT.println("beacon off");
            }

          if ( tmp_string == "send" ) 
            { 
              SerialBT.println("beacon forced");
              tx_interval = 0;
            }

          if ( tmp_string == "xmode") 
            { 
              Xmode = !Xmode;
              if (Xmode) SerialBT.println("xmode on");
              if (!Xmode) SerialBT.println("xmode off");
              lora_setup();
            }

          if ( tmp_string == "display") 
            { 
              displayOn = !displayOn;
              if (displayOn)
                 {  
                  SerialBT.println("OLED on");
                  display.dim(false);
                  }
              if (!displayOn)
                 {  
                  SerialBT.println("OLED off");
                  display.dim(true);
                  }
              display.display();
            }

          if ( tmp_string == "led") 
            { 
              ledOn = !ledOn;
              if (ledOn)SerialBT.println("LED on");
              if (!ledOn)SerialBT.println("LED off");
            }
          
          if ( dataOK ) LoRa_send();    
          if ( !dataOK ) tmp_string="";    
          make_display();                     
        }
      delay(20);
    }
    
}
//############// FINE DI LOOP ###########################


   
  /*
  ---------------------------------------------------------------------------
    INVIO DATI 
  ---------------------------------------------------------------------------
  */

void LoRa_send()
  {
 
    if ( !token || !dataOK )
      {
        Serial.print(F("NOT SEND: "));
        if (!token)  Serial.println("too fast TX");
        if (!dataOK) Serial.println("no valid data to TX");
        tmp_string="";
        dataOK=false;
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.setTextSize(2);
        display.setCursor(16,10);
        display.print("NOT SEND");
        display.setTextSize(1);
        display.setCursor(0,50);
        if (!token) display.print("too fast TX");
        if (!dataOK )display.print("no valid data to TX");
        display.display();
        if (!displayOn && ledOn) fast_blink(); 
        if (!ledOn ) delay(2000);
        make_display();   // carica display con dati correnti
 
        
      }
   
    if ( token && dataOK )
      {   
        data_string = "";
        tmp= int(battery_voltage * 100 );
        byte centinaia  = ( tmp / 100 );                        // calculo del valor dell unita
        byte decine  = (tmp - (centinaia * 100)) / 10;          // alculo del valor de dec1
        byte unita =  tmp - (centinaia * 100) - (decine * 10);  // calculo del valor de dec2
        data_string = tmp_string + ' ' + '|' + ' ' + 'b' + 'a' + 't' + 't' + ':' + char(48+centinaia) + '.' +char(48+decine) + char(48+unita);

        cnt++;
        if (cnt > 999 ) cnt = 0;
        centinaia =  cnt / 100;                            // calculo del valor de centenas
        decine  = (cnt - (centinaia * 100)) / 10;          // calculo del valor de decenas
        unita =  cnt - (centinaia * 100) - (decine * 10);  // calculo del valor de unidades
        data_string = data_string+ ' ' + '|' + ' ' + char(48+centinaia) + char(48+decine) + char(48+unita) + char(10) ; // CR and LF are control characters, respectively coded 0x0D (13 decimal) and 0x0A (10 decimal).
        Serial.println(data_string);

    
            display.clearDisplay();
            display.setTextColor(WHITE);
            display.setTextSize(3);
            display.setCursor(30,10);
            display.print("SEND");
            display.setTextSize(2);
            display.setCursor(50,40);
            if(cnt<100)  {display.print("0");}
            if(cnt<10)   {display.print("0");}
            display.print(cnt);battery:
            display.display();

        
        if (ledOn )  digitalWrite(PLED1,HIGH);
        lora_send(data_string);
        LoRa.sleep();
        if (ledOn )  digitalWrite(PLED1,LOW);
        token = false;
        mem_tmp_string = tmp_string;
        sep = mem_tmp_string.indexOf(58);           // uso temporaneo della variabile sep per trovare la posizione di ':' nella stringa
        if (sep != 0 ) 
          { 
            mem_tmp_string.setCharAt(sep+10, 92);   // sostituisci il simbolo di sperazione lat/long con il simbolo '\' = ASCII 92
            mem_tmp_string.setCharAt(sep+20, 111);  // sostituisci il simbolo APRS con il simbolo 'o' = ASCII = 111
          }
        tmp_string = "";  
        tx_interval = millis();                    // memorizza l'istante di invio
        make_display();   // carica display con dati correnti  
      } 
  }



  /*
  ---------------------------------------------------------------------------
    GRAPHIC DISPLAY 
  ---------------------------------------------------------------------------
  */
  
void make_display()
  {
    display.clearDisplay();
    display.setTextColor(WHITE);
    display.setTextSize(1);
    display.setCursor(0,12);
    display.print("battery: ");
    display.print(battery_voltage);
    display.println(" Volt");
    display.setCursor(0,24);
    display.print("sended: ");
    display.print(cnt);
    if (!Beacon) display.print(" string");
    if (Beacon) display.print(" beacon");
    display.setCursor(0,36);
    display.println("---------------------");
    display.setCursor(0,48);
    if (Xmode )display.println("Xmode active !");
    else 
      {
        display.print(Project);
        display.print(" " );
        display.print(Release);
      }
    display.display();  
  }



  /*
  ---------------------------------------------------------------------------
    LETTURA CARATTERE SCELTA MENU 
  ---------------------------------------------------------------------------
  */

char readCarMenu()
{
  //char car = 0;
  char ret = 0;
  ret = 0;
  while (car != '\n')
    {
      if (Serial.available() > 0)
        {
          car = Serial.read();
          if ((car >= 48) && (car <= 57) || (car >= 97) && (tmp <= 122) ) ret = car;
        }
    }
  car=0;
  return ret;
}



  /*
  ---------------------------------------------------------------------------
    FUNZIONE LETTURA DIGITAZIONI DA MENU 
  ---------------------------------------------------------------------------
  */
  
int readCharArray(char *tmp_buffer)
{
  char car;
  sep=0;
  ptr=0;
  do
    {
      if (Serial.available() > 0)
        {
          car = Serial.read();
          if ( carMenu == 'c'  )       // per il menu 1 converti in maiuscolo
            {  
              if ( car >= 97 && car <= 122 ) car = car-32;  // converti da minuscolo a maiuscolo
            }
          
          
          if (car != '\n' && car != ' ' && carMenu == 'l' || car != '\n' && carMenu != 'l')
            {
              tmp_buffer[ptr++] = car;
            }
          if (car == ',')
            {
              sep=ptr-1;
            }
            
        }
    }
  while (car != '\n');
  
  tmp_buffer[ptr] = 0;
  
  return ptr;
  return sep;
}



  /*
  ---------------------------------------------------------------------------
    RIGHELLO 
  ---------------------------------------------------------------------------
  */

void righello()
{
  tmp=0;
  while (tmp != 42)
    {
      Serial.print(F("- "));
      tmp++;  
    }
    Serial.println();
    tmp=0;
}



  /*
  ---------------------------------------------------------------------------
    MENU 
  ---------------------------------------------------------------------------
  */
  
void menu()
{
  do
    {
      carMenu = 0;
      righello();
      Serial.println(F(".. config menu .."));
      righello();
      Serial.println(F("(f)requency"));
      Serial.println(F("(p)ower"));
      Serial.println(F("(t)x interval"));
      Serial.println(F("(d)isplay OLED"));
      Serial.println(F("(l)ed"));
      Serial.println(F("(0) EXIT"));
      righello();
    
      carMenu = readCarMenu();
      switch (carMenu)
        {
          case '0' :
           status();
           break;

          case 'p' :
            Serial.print(F("power 2-17 dBm - ex: 17"));
            readCharArray(tmp_buffer);
            LoRa_power = atoi(tmp_buffer);
            verifica_parametri();
            
            Serial.print(F(" = "));
            Serial.println(LoRa_power);
            EEPROM.write(38, LoRa_power);
            EEPROM.commit();
            lora_setup();
            break;


            case 'x' :
            Xmode = !Xmode;
            lora_setup();
            if (Xmode ) Serial.println(F("Xmode actived"));
            if (!Xmode ) Serial.println(F("Xmode disactived"));
            //EEPROM.write(8, Xmode);
            //EEPROM.commit(); 
            break;
         
          case 'd' :
            displayOn = !displayOn;
            if (displayOn )
              { 
                Serial.println(F("OLED actived"));
                display.dim(false);  
              }
            if (!displayOn )
              { 
                Serial.println(F("OLED disactived"));
                display.dim(true);  
              }
            EEPROM.write(6, displayOn);
            EEPROM.commit(); 
            break;

          case 'l' :
            ledOn = !ledOn;
            if (ledOn ) Serial.println(F("LED actived"));
            if (!ledOn ) Serial.println(F("LED disactived"));
            EEPROM.write(7, ledOn);
            EEPROM.commit(); 
            break;

          case 't' :
            Serial.print(F("tx interval 15 to 120 secs - ex: 30"));
            readCharArray(tmp_buffer);
            val_tx_interval = atoi(tmp_buffer);
            verifica_parametri();
            Serial.print(F(" = "));
            Serial.println(val_tx_interval);
            EEPROM.write(40, val_tx_interval);
            EEPROM.commit();
            break;
         
          case 'f' :
            Serial.print(F("frequency - ex: 433775"));
            readCharArray(frequency);
            tmp = 41;                          // inizia a scrivere dalla posizione 41 fino alla 46
            while (tmp != 47)               
              {
                EEPROM.write( tmp, frequency[tmp-41] );
                tmp++;  
              }
            EEPROM.commit();
            Serial.print(F(" = "));  
            Serial.println(frequency);
            lora_setup();

            break;
            
         }        
  } while (carMenu != '0' );
  Serial.println();
}



  /*
  ---------------------------------------------------------------------------
    STATUS SERIAL DISPLAY 
  ---------------------------------------------------------------------------
  */

void status()
  {
    righello();
    Serial.print(F(Project));
    Serial.print(F(" "));
    Serial.print(F(Release));
    Serial.print(F(" - built "));
    Serial.print(F(build));
    Serial.print(F(" by "));
    Serial.println(F(Maker));
    righello();

    Serial.print(F("frequency: "));
    Serial.print(frequency);
    Serial.println(F(" KHz"));
    
    Serial.print(F("power: "));
    Serial.print(LoRa_power);
    Serial.println(F(" dBm"));

    Serial.print(F("tx interval: "));
    Serial.print(val_tx_interval);
    Serial.println(F(" secs"));
    
    Serial.print(F("display: "));
    if (displayOn ) Serial.println(F("ON"));
    if (!displayOn ) Serial.println(F("OFF"));
    
    Serial.print(F("led: "));
    if (ledOn ) Serial.println(F("ON"));
    if (!ledOn ) Serial.println(F("OFF"));

    Serial.print(F("battery: "));
    Serial.print(battery_voltage);
    Serial.println(F(" Volt"));

    if(Xmode ) Serial.println(F("Xmode is active"));
    
    righello();
    Serial.println(F(bottom));
 }



  /*
  ---------------------------------------------------------------------------
    CARICAMENTO PARAMETRI
  ---------------------------------------------------------------------------
  */

void load_param()
  {
    /* ---------------------- determina se occorre factory reset 
      il primi 6 caratteri della EEPROM si attendono il dato della build
      se non coincide cosa si legge in EEPROM viene avviata la routine di factory reset
    */ 

    boolean verify = LOW;
    tmp=0;
    while ( tmp != 6  )       // leggi dalla cella 0 fino alla cella 6 
      {
        car = EEPROM.read(tmp);
        if (car != build[tmp] ) verify = true; // verificare da scansione se build e build_mark sono uguali
        tmp++;
      }

    if ( verify == true )
      {
        Serial.println(F("initial reset required")); 
        initial_reset();        // carica valori di default nella EEPROM
      }
 
    displayOn = EEPROM.read(6);
    ledOn = EEPROM.read(7);
    //Xmode = EEPROM.read(8);
    LoRa_power = EEPROM.read(38);

    val_tx_interval = EEPROM.read(40);

    tmp = 41;
    while ( tmp != 47)  // leggi dalla cella 41 fino alla 46
      {
        car = EEPROM.read(tmp);
        frequency[tmp-41] = car;
        tmp++;
      }
 }



  /*
  ---------------------------------------------------------------------------
    RESET INIZIALE
  ---------------------------------------------------------------------------
  */

void initial_reset()
  {
    
    tmp=0;
    while (tmp != EEPROM_SIZE)
      {
        EEPROM.write( tmp, ' ' );      
        tmp++;    // avanza di una cella EEPROM
      }
    EEPROM.commit();
    Serial.println(F("EEPROM erased"));
        
    tmp = 0;
    while (tmp != 6)
      {
        EEPROM.write( tmp, build[tmp] );         // valore di build si scrive a partire dalla cella 0 fino alla 5
        tmp++;    // avanza di una cella EEPROM
      }
   
    EEPROM.write(6, displayOn);
    EEPROM.write(7, ledOn);
    //EEPROM.write(8, Xmode);
    EEPROM.write(38, LoRa_power);
    EEPROM.write(40, val_tx_interval);

    tmp = 41;                          // inizia a scrivere dalla posizione 41 per 46 caratteri
    while (tmp != 47)
      {
        EEPROM.write( tmp, frequency[tmp-41] );
        tmp++;  
      }

  EEPROM.commit();
         
   tmp=0;
   Serial.println(F("initial reset executed")); 
}



  /*
  ---------------------------------------------------------------------------
    VERIFICA PARAMETRI
  ---------------------------------------------------------------------------
  */

void verifica_parametri()
  {
    tmp=0;

    
    if (LoRa_power <2 ) LoRa_power = 2;
    if (LoRa_power >17 ) LoRa_power = 17;
    if (val_tx_interval <15 ) val_tx_interval = 30;   // da 15 secondi a 120 secondi
    if (val_tx_interval >120 ) val_tx_interval = 120;

  }



  /*
  ---------------------------------------------------------------------------
    ROUTINE FAST BLINK 
  ---------------------------------------------------------------------------
  */
void fast_blink()
  {
    tmp=0;
    while (tmp != 6)
      {
        digitalWrite(PLED1, HIGH);
        delay (100);
        digitalWrite(PLED1, LOW);
        delay (100);
        tmp++;  
       }
  }



   /*
  ---------------------------------------------------------------------------
    GESTIONE LETTURA BATTERIA
  ---------------------------------------------------------------------------
  */
  
void read_battery()
  {
    uint16_t v1 = analogRead(BATT_SENS);
    battery_voltage = ((float)v1 / 4095.0) * 2.0 * 3.3 * (1100 / 1000.0);
  }


void lora_setup() {
  SPI.begin(LoRa_SCK, LoRa_MISO, LoRa_MOSI, LoRa_SS);
  LoRa.setPins(LoRa_SS, LoRa_RST, LoRa_DIO0);
  if (!LoRa.begin(atoi(frequency)*1000)) {
    Serial.println("Failed to setup LoRa module.");
    while (1);
  }
  if (Xmode )
    {
      LoRa.setSpreadingFactor(LoRa_XSpreadingFactor);   // --- parametri veloci
      LoRa.setSignalBandwidth(LoRa_XSignalBandwidth);
      LoRa.setCodingRate4(LoRa_XCodingRate4);
    }  
  else
    {  
      LoRa.setSpreadingFactor(LoRa_SpreadingFactor);    // --- parametri std
      LoRa.setSignalBandwidth(LoRa_SignalBandwidth);
      LoRa.setCodingRate4(LoRa_CodingRate4);
    }

  LoRa.enableCrc();
  LoRa.setTxPower(LoRa_power);
  delay(500);
}


void lora_send(String tx_data) {
  LoRa.beginPacket();
  LoRa.write('<');
  LoRa.write(0xFF);
  LoRa.write(0x01);
  LoRa.write((const uint8_t *)tx_data.c_str(), tx_data.length());
  LoRa.endPacket();
  }



  /*
  ---------------------------------------------------------------------------
    EEPROM MAP
  ---------------------------------------------------------------------------


  byte of the EEPROM can only hold a
  value from 0 to 255.
 
  
0 - 5   // build:230405 | 6
6 - 6   // displayOn | default = true
7 - 7   // ledOn | default = true
8 - 8   // Xmode on/off | 1 = on | 0 = off 
38 - 38 // set power: 2-17 | 1
39 - 39 // set nr_send 1-3 | 1
40 - 40 // set tx_interval 15-120 | valori da 1 a 2 --> da 15 secondi a 120 secondi
41 - 41 // centinaia di MHz
42 - 42 // decine di MHz
43 - 43 // unita di MHz
44 - 44 // centinaia di KHz
45 - 45 // decine di KHz
46 - 46 // unita di KHz


 */
